package edu.wisc.library.sdg.preservation.worker.util;

import com.google.common.io.MoreFiles;
import com.google.common.io.RecursiveDeleteOption;
import com.google.common.net.UrlEscapers;
import edu.wisc.library.sdg.preservation.common.util.ArgCheck;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.nio.file.FileSystemException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Component
public class WorkDirectory {

    private static final Logger LOG = LoggerFactory.getLogger(WorkDirectory.class);

    private static final String SOURCE = "source";
    private static final String WIP = "wip";
    private static final String PREFIX = "batch-";

    private final Path workDir;

    @Autowired
    public WorkDirectory(@Value("${app.work.dir}") Path workDir) {
        this.workDir = workDir;
    }

    /**
     * Root directory that contains all of the files related to processing an ingest batch
     */
    public Path batchDirectory(Long ingestId) {
        ArgCheck.notNull(ingestId, "ingestId");

        return workDir.resolve(PREFIX + ingestId);
    }

    /**
     * Directory within the batch root directory that contains all of the files that were submitted by the user to
     * be ingested.
     */
    public Path batchSourceDirectory(Long ingestId) {
        return batchDirectory(ingestId).resolve(SOURCE);
    }

    /**
     * Directory within the batch root directory that contains all of the files that are generated by the system as
     * part of processing the batch for ingestion.
     */
    public Path batchWipDirectory(Long ingestId) {
        return batchDirectory(ingestId).resolve(WIP);
    }

    /**
     * Directory within the batch wip directory that contains all of the files that are generated by the system as
     * part of processing the batch for ingestion that are related to a specific object in the batch.
     */
    public Path batchObjectWipDirectory(Long ingestId, String objectId) {
        ArgCheck.notBlank(objectId, "objectId");
        var encodedId = UrlEscapers.urlFormParameterEscaper().escape(objectId);
        return batchWipDirectory(ingestId).resolve(encodedId);
    }

    public void deleteBatchDirectory(Long ingestId) {
        var path = batchDirectory(ingestId);

        if (Files.exists(path)) {
            try {
                LOG.info("Deleting directory: {}", path);
                deleteRecursively(path);
                LOG.info("Successfully deleted directory: {}", path);
            } catch (IOException e) {
                throw new UncheckedIOException(e);
            }
        }
    }

    /**
     * Returns a list of all of the ingest ids that have work directories
     *
     * @return list of ingest ids with work directories
     */
    public List<Long> listIngestIds() {
        try (var files = Files.list(workDir)) {
            return files.map(Path::getFileName)
                    .map(Path::toString)
                    .filter(name -> name.startsWith(PREFIX))
                    .map(name -> {
                        try {
                            return Long.parseLong(name.split("-", 2)[1]);
                        } catch (Exception e) {
                            return null;
                        }
                    }).filter(Objects::nonNull)
                    .toList();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }

    private void deleteRecursively(Path path) throws IOException {
        if (Files.isDirectory(path)) {
            var children = getChildren(path);
            while (!children.isEmpty()) {
                for (var child : children) {
                    try {
                        deleteRecursively(child);
                    } catch (IOException e) {
                        LOG.warn("Failed to delete {}", child);
                        throw e;
                    }
                }

                children = getChildren(path);
            }
        }

        Files.deleteIfExists(path);
    }

    private List<Path> getChildren(Path path) throws IOException {
        try (var children = Files.list(path)) {
            return children.toList();
        }
    }
}
